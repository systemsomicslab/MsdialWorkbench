using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;
using System.Text;
using System.Xml.Linq;

namespace CompMs.Common.Lipidomics.SourceGenerator;

[Generator(LanguageNames.CSharp)]
public partial class LipidSpectrumGeneratorTypeGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context) {
#if DEBUG
        if (!System.Diagnostics.Debugger.IsAttached) {
            // System.Diagnostics.Debugger.Launch();
        }
#endif

        var additionalFiles = context.AdditionalTextsProvider
            .Where(f => f.Path.EndsWith(".xml"));
        var metadataProvider = context.AnalyzerConfigOptionsProvider;

        var constantFiles = additionalFiles.Combine(metadataProvider)
            .SelectMany((pair, cancellationToken) => {
                var (file, provider) = pair;
                var metadata = provider.GetOptions(file);
                if (!metadata.TryGetValue("build_metadata.AdditionalFiles.IsConstants", out var isConstants)
                    || !string.Equals(isConstants, "true", StringComparison.CurrentCultureIgnoreCase)) {
                    return Array.Empty<AdditionalText?>();
                }
                return [file];
            }).Collect();
        context.RegisterSourceOutput(constantFiles, (spc, files) => {
            EmitConstants(spc, files);
        });

        var targetFiles = additionalFiles.Combine(metadataProvider)
            .SelectMany((pair, cancellationToken) => {
                var (file, provider) = pair;
                var metadata = provider.GetOptions(file);
                if (metadata.TryGetValue("build_metadata.AdditionalFiles.IsConstants", out var isConstants)
                    && string.Equals(isConstants, "true", StringComparison.CurrentCultureIgnoreCase)) {
                    return [];
                }
                return metadata.TryGetValue("build_metadata.AdditionalFiles.Category", out var category)
                    ? new[] { new { Path = file.Path, Category = category, File = file, } }
                    : new[] { new { Path = file.Path, Category = string.Empty, File = file, } };
            }).Collect();
        context.RegisterSourceOutput(targetFiles.Combine(constantFiles), (spc, pair) => {
            var (files, constants) = pair;
            var defs = CollectDefinitions(files.Select(f => f.File).ToList(), spc.CancellationToken);
            foreach (var group in files.GroupBy(f => f.Category)) {
                Emit(spc, group.Select(o => o.File), group.Key, defs, constants);
            }
        });
    }

    private List<LipidDefinition> CollectDefinitions(IEnumerable<AdditionalText> files, CancellationToken token) {
        var results = new List<LipidDefinition>();
        foreach (var file in files) {
            var content = file.GetText(token)?.ToString();
            if (content is null) {
                continue;
            }

            var doc = XDocument.Parse(content);
            foreach (var def in doc.Descendants("LipidDefinition")) {
                results.Add(new LipidDefinition
                {
                    Name = def.Element("Name")?.Value ?? string.Empty,
                    NumOfChains = int.TryParse(def.Element("Chain")?.Value, out var n) ? n : 0,
                });
            }
        }
        return results;
    }

    private static void EmitConstants(SourceProductionContext spc, IEnumerable<AdditionalText> files) {
        var builder = new StringBuilder();
        builder.Append("""
// <auto-generated/>
#nullable enable
#pragma warning disable CS8600
#pragma warning disable CS8601
#pragma warning disable CS8602
#pragma warning disable CS8603
#pragma warning disable CS8604

using CompMs.Common.FormulaGenerator.DataObj;
using System;

namespace CompMs.Common.Lipidomics {

    internal static class ConstantFormulas {
        public static readonly double e = .000548579909070;

""");
        foreach (var file in files) {
            var content = file.GetText(spc.CancellationToken)?.ToString();
            var doc = XDocument.Parse(content);
            var constantsElement = doc.Element("Constants");
            if (constantsElement is null) {
                continue;
            }

            foreach (var elem in constantsElement.Elements()) {
                builder.AppendLine($"        public static readonly double {elem.Name} = {elem.Value};");
            }
        }
builder.Append("""
    }
}
""");

        spc.AddSource("ConstantFormulas.g.cs", SourceText.From(builder.ToString(), Encoding.UTF8));
    }

    private static void Emit(SourceProductionContext spc, IEnumerable<AdditionalText> files, string? category, List<LipidDefinition> defs, IEnumerable<AdditionalText> constantFiles) {
        var constants = new List<(string, string)>();
        foreach (var file in constantFiles) {
            var content = file.GetText(spc.CancellationToken)?.ToString();
            var doc = XDocument.Parse(content);
            var constantsElement = doc.Element("Constants");
            if (constantsElement is null) {
                continue;
            }

            foreach (var elem in constantsElement.Elements()) {
                constants.Add((elem.Name.ToString(), elem.Value));
            }
        }

        var result = new StringBuilder();
        result.Append("""
// <auto-generated/>
#nullable enable
#pragma warning disable CS8600
#pragma warning disable CS8601
#pragma warning disable CS8602
#pragma warning disable CS8603
#pragma warning disable CS8604

using CompMs.Common.Components;
using CompMs.Common.DataObj.Property;
using CompMs.Common.FormulaGenerator.DataObj;
using static CompMs.Common.Lipidomics.ConstantFormulas;
using System;
using System.Collections.Generic;
using System.ComponentModel;

namespace CompMs.Common.Lipidomics {

""");

        IEnumerable<XElement> lipidMSElements = [];
        foreach (var file in files) {
            var content = file.GetText(spc.CancellationToken)?.ToString();
            if (content is null) {
                continue;
            }

            var doc = XDocument.Parse(content);
            lipidMSElements = lipidMSElements.Concat(doc.Descendants("LipidMS").Where(e => e.Elements("LipidClass").Any()));
        }

        var ctx = new Context([.. constants]);

        foreach (var group in lipidMSElements.GroupBy(e => e.Element("LipidClass").Value)) {
            var lipidClass = group.Key;

            var lipidMSs = group.Select(e => ToLipidMS(ctx, e)).ToList();

            result.AppendLine();
            result.AppendLine($"    public sealed class {lipidClass}{category ?? string.Empty}LipidSpectrumGenerator  {{");

            result.AppendLine("""
        public List<SpectrumPeak>? Generate(Lipid lipid, AdductIon adduct) {
            double M;
            var chains = lipid.Chains.GetDeterminedChains();
""");

            var def = defs.FirstOrDefault(d => d.Name == lipidClass);
            if (def is not null) {
                result.AppendLine($"""
            double {string.Join(", ", Enumerable.Range(1, def.NumOfChains).Select(i => "SN" + i))};
""");
            }

            result.AppendLine("""
            var peaks = new List<SpectrumPeak>();
            switch (adduct.AdductIonName) {
""");

            foreach (var lipidMS in lipidMSs) {
                result.AppendLine($"""
                case "{lipidMS.Adduct}":
                    M = lipid.Mass;
""");

                if (def is not null && lipidMS.Ions.SelectMany(ions => ions.Value).Any(ion => ion.Mz.Contains("SN"))) {
                    result.AppendLine(ForEachLine("                    ", Enumerable.Range(0, def.NumOfChains).Select(i => $"SN{i + 1} = chains[{i}].Mass;")));
                }

                foreach (var ions in lipidMS.Ions) {
                    if (!ions.Value.Any()) {
                        continue;
                    }

                    result.AppendLine($"""

                    // {ions.Key}
                    peaks.AddRange([
{ForEachLine("                        ", ions.Value.Select(ion => $"new SpectrumPeak({ion.Mz}, {ion.Intensity}, \"{ion.Comment}\"),"))}
                    ]);
""");
                }

                result.AppendLine("""
                    return peaks;

""");
            }

            result.AppendLine("""
                default: return null;
            }
        }
""");


            result.AppendLine("    }");
        }

        result.AppendLine("}");
        spc.AddSource($"{category}LipidSpectrumGenerator.g.cs", SourceText.From(result.ToString(), Encoding.UTF8));
    }

    private static string ForEachLine(string indent, IEnumerable<string> contents) {
        return indent + string.Join(Environment.NewLine + indent, contents);
    }

    readonly static List<string> _specialElements = ["LipidClass", "LSILevel", "Adduct"];

    private static LipidMS ToLipidMS(Context ctx, XElement element) {
        var adduct = element.Element("Adduct")?.Value ?? string.Empty;
        var lsiLevel = Enum.TryParse<LSILevel>(element.Element("LSILevel")?.Value, out var lsi) ? lsi : LSILevel.None;
        var ions = new Dictionary<string, List<Ion>>();

        var ionElements = element.Elements().Where(e => !_specialElements.Contains(e.Name.LocalName));

        foreach (var ionGroup in ionElements) {
            var key = ionGroup.Name.LocalName;
            if (!ions.TryGetValue(key, out var list)) {
                ions[key] = ionGroup.Elements().Select(e => ToIon(ctx, e)).ToList();
                continue;
            }
            list.AddRange(ionGroup.Elements().Select(e => ToIon(ctx, e)).ToList());
        }

        return new(adduct, lsiLevel, ions);
    }

    readonly static List<string> _peakElements = ["MZ", "Intensity", "Comment", "Charge", "Formula"];

    private static Ion ToIon(Context ctx, XElement element) {
        var mz = element.Element("MZ")?.Value ?? string.Empty;
        var intensity = element.Element("Intensity")?.Value ?? "0";
        var comment = element.Element("Comment")?.Value ?? string.Empty;
        var charge = element.Element("Charge")?.Value ?? "0";
        var formula = element.Element("Formula")?.Value ?? string.Empty;

        using var handle = ctx.CreateRegisterHandle();
        LoadElements(handle, element);
        var parser = new FormulaSentenceParser();
        if (parser.Parse(mz) is { } mzSentence) {
            mz = ctx.Resolve(mzSentence);
        }
        else if (charge != "0" && int.TryParse(charge, out var c) && parser.Parse(formula) is { } formulaSentence) {
            formula = ctx.Resolve(formulaSentence);
            mz = $"(({formula}) - ({c} * e)) / {Math.Abs(c)}";
        }

        return new() { Mz = mz, Intensity = intensity, Comment = comment };
    }

    private static void LoadElements(Context.RegisterHandle handle, XElement element) {
        var parser = new FormulaSentenceParser();
        foreach (var variable in element.Elements().Where(e => !_peakElements.Contains(e.Name.LocalName))) {
            if (variable.HasElements) {

            }
            var sub = variable.HasElements
                ? parser.Parse(variable.Name.LocalName, variable.ToString())
                : parser.Parse(variable.Name.LocalName, variable.Value);
            if (sub is not null) {
                handle.Register(sub);
            }
        }
    }

    enum LSILevel {
        None,
        SpeciesLevel,
        MolecularSpeciesLevel,
    }

    class LipidMS(string adduct, LSILevel lsiLevel, Dictionary<string, List<Ion>> ions) {
        public string Adduct { get; } = adduct;
        public LSILevel LSILevel { get; } = lsiLevel;
        public Dictionary<string, List<Ion>> Ions { get; } = ions;
    }

    class Ion
    {
        public string Mz { get; set; } = "0";
        public string Intensity { get; set; } = "0";
        public string Comment { get; set; } = string.Empty;
    }

    class LipidDefinition {
        public string Name { get; set; } = string.Empty;
        public int NumOfChains { get; set; }
    }
}
