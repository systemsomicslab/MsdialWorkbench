using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;
using System.Text;
using System.Xml.Linq;

namespace CompMs.Common.Lipidomics.SourceGenerator;

[Generator(LanguageNames.CSharp)]
public partial class LipidSpectrumGeneratorTypeGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context) {
#if DEBUG
        if (!System.Diagnostics.Debugger.IsAttached) {
            // System.Diagnostics.Debugger.Launch();
        }
#endif

        var additionalFiles = context.AdditionalTextsProvider
            .Where(f => f.Path.EndsWith(".xml"));
        var metadataProvider = context.AnalyzerConfigOptionsProvider
            .Select((provider, _) => provider);
        var targetFiles = additionalFiles.Combine(metadataProvider)
            .SelectMany((pair, cancellationToken) => {
                var (file, provider) = pair;
                var metadata = provider.GetOptions(file);
                //metadata.TryGetValue("build_metadata.Category", out var xxx);
                //metadata.TryGetValue("build_metadata.AdditionalFiles.Category", out var yyy);

                return metadata.TryGetValue("build_metadata.Category", out var category)
                    ? new[] { new { Path = file.Path, Category = category, File = file, } }
                    : new[] { new { Path = file.Path, Category = string.Empty, File = file, } };
            }).Collect();

        context.RegisterSourceOutput(targetFiles, (spc, files) => {
            var defs = CollectDefinitions(files.Select(f => f.File).ToList(), spc.CancellationToken);
            foreach (var group in files.GroupBy(f => f.Category)) {
                Emit(spc, group.Select(o => o.File), group.Key, defs);
            }
        });

        context.RegisterPostInitializationOutput(EmitStandardFormulas);
    }

    private List<LipidDefinition> CollectDefinitions(IEnumerable<AdditionalText> files, CancellationToken token) {
        var results = new List<LipidDefinition>();
        foreach (var file in files) {
            var content = file.GetText(token)?.ToString();
            if (content is null) {
                continue;
            }

            var doc = XDocument.Parse(content);
            foreach (var def in doc.Descendants("LipidDefinition")) {
                results.Add(new LipidDefinition
                {
                    Name = def.Element("Name")?.Value ?? string.Empty,
                    NumOfChains = int.TryParse(def.Element("Chain")?.Value, out var n) ? n : 0,
                });
            }
        }
        return results;
    }

    private static void EmitStandardFormulas(IncrementalGeneratorPostInitializationContext context) {
        context.AddSource("StandardFormulas.cs", """
// <auto-generated/>
#nullable enable
#pragma warning disable CS8600
#pragma warning disable CS8601
#pragma warning disable CS8602
#pragma warning disable CS8603
#pragma warning disable CS8604

using CompMs.Common.FormulaGenerator.DataObj;
using System;

namespace CompMs.Common.Lipidomics {

    internal static class StandardFormulas {
        public static readonly double H2O = MassDiffDictionary.HydrogenMass * 2 + MassDiffDictionary.OxygenMass;
        public static readonly double C = MassDiffDictionary.CarbonMass;
        public static readonly double Carbon = MassDiffDictionary.CarbonMass;
        public static readonly double H = MassDiffDictionary.HydrogenMass;
        public static readonly double Hydrogen = MassDiffDictionary.HydrogenMass;
        public static readonly double N = MassDiffDictionary.NitrogenMass;
        public static readonly double Nitrogen = MassDiffDictionary.NitrogenMass;
        public static readonly double O = MassDiffDictionary.OxygenMass;
        public static readonly double Oxygen = MassDiffDictionary.OxygenMass;
        public static readonly double S = MassDiffDictionary.SulfurMass;
        public static readonly double Sulfur = MassDiffDictionary.SulfurMass;
        public static readonly double P = MassDiffDictionary.PhosphorusMass;
        public static readonly double Phosphorus = MassDiffDictionary.PhosphorusMass;
        public static readonly double Proton = MassDiffDictionary.ProtonMass;
        public static readonly double Electron = MassDiffDictionary.HydrogenMass - MassDiffDictionary.ProtonMass;
        public static readonly double HCOO = H * 2.0 + C * 1 + O * 2.0 - Proton;
        public static readonly double CH3COO = H * 4.0 + C * 2 + O * 2.0 - Proton;
        public static readonly double Na = 22.98976928 - Electron;
    }
}
""");
    }

    private static void Emit(SourceProductionContext spc, IEnumerable<AdditionalText> files, string? category, List<LipidDefinition> defs) {
        var result = new StringBuilder();
        result.Append("""
// <auto-generated/>
#nullable enable
#pragma warning disable CS8600
#pragma warning disable CS8601
#pragma warning disable CS8602
#pragma warning disable CS8603
#pragma warning disable CS8604

using CompMs.Common.Components;
using CompMs.Common.DataObj.Property;
using CompMs.Common.FormulaGenerator.DataObj;
using static CompMs.Common.Lipidomics.StandardFormulas;
using System;
using System.ComponentModel;

namespace CompMs.Common.Lipidomics {

""");

        IEnumerable<XElement> lipidMSElements = [];
        foreach (var file in files) {
            var content = file.GetText(spc.CancellationToken)?.ToString();
            if (content is null) {
                continue;
            }

            var doc = XDocument.Parse(content);
            lipidMSElements = lipidMSElements.Concat(doc.Descendants("LipidMS").Where(e => e.Elements("LipidClass").Any()));
        }

        foreach (var group in lipidMSElements.GroupBy(e => e.Element("LipidClass").Value)) {
            var lipidClass = group.Key;

            var lipidMSs = group.Select(ToLipidMS).ToList();

            result.AppendLine();
            result.AppendLine($"    public sealed class {lipidClass}{category ?? string.Empty}SpectrumGenerator  {{");

            result.AppendLine("""
        public List<SpectrumPeak>? Generate(Lipid lipid, AdductIon adduct) {
            var peaks = new List<SpectrumPeak>();
            switch (adduct.AdductIonName) {
""");

            foreach (var lipidMS in lipidMSs) {
                result.AppendLine($"""
                case "{lipidMS.Adduct}":
                    var M = lipid.Mass;
                    var chains = lipid.Chains.GetDeterminedChains();
""");

                if (defs.FirstOrDefault(d => d.Name == lipidClass) is { } def) {
                    for (int i = 0; i < def.NumOfChains; i++) {
                        result.AppendLine($"""
                    var SN{i + 1} = chains[{i}].Mass;
""");
                    }
                }

                foreach (var ions in lipidMS.Ions) {
                    result.AppendLine($"""

                    // {ions.Key}
""");
                    foreach (var ion in ions.Value) {
                        result.AppendLine($"""
                    peaks.Add(new SpectrumPeak({ion.Mz}, {ion.Intensity}, "{ion.Comment}"));
""");
                    }
                }

                result.AppendLine("""
                    return peaks;
""");
            }

            result.AppendLine("""
                default: return null;
            }
        }
""");


            result.AppendLine("    }");
        }

        result.AppendLine("}");
        spc.AddSource($"{category}LipidSpectrumGenerator.g.cs", SourceText.From(result.ToString(), Encoding.UTF8));
    }

    readonly static List<string> _specialElements = ["LipidClass", "LSILevel", "Adduct"];

    private static LipidMS ToLipidMS(XElement element) {
        var adduct = element.Element("Adduct")?.Value ?? string.Empty;
        var LSILevel = element.Element("LSILevel")?.Value ?? string.Empty;
        var ions = new Dictionary<string, List<Ion>>();


        var ionElements = element.Elements().Where(e => !_specialElements.Contains(e.Name.LocalName));

        foreach (var ionGroup in ionElements) {
            var key = ionGroup.Name.LocalName;
            if (!ions.TryGetValue(key, out var list)) {
                ions[key] = ionGroup.Elements().Select(ToIon).ToList();
                continue;
            }
            list.AddRange(ionGroup.Elements().Select(ToIon).ToList());
        }

        return new(adduct, LSILevel, ions);
    }

    readonly static List<string> _peakElements = ["MZ", "Intensity", "Comment"];

    private static Ion ToIon(XElement element) {
        var mz = element.Element("MZ")?.Value ?? "0";
        var intensity = element.Element("Intensity")?.Value ?? "0";
        var comment = element.Element("Comment")?.Value ?? string.Empty;

        foreach (var variable in element.Elements().Where(e => !_peakElements.Contains(e.Name.LocalName))) {
            var name = variable.Name.LocalName;

            var formula = string.Join(" + ", variable.Elements().Select(e => $"{e.Name.LocalName} * {e.Value}"));
            mz = mz.Replace(name, $"({formula})");
        }

        return new() { Mz = mz, Intensity = intensity, Comment = comment };
    }

    class LipidMS(string adduct, string lsiLevel, Dictionary<string, List<Ion>> ions) {
        public string Adduct { get; } = adduct;
        public string LSILevel { get; } = lsiLevel;
        public Dictionary<string, List<Ion>> Ions { get; } = ions;
    }

    class Ion
    {
        public string Mz { get; set; } = "0";
        public string Intensity { get; set; } = "0";
        public string Comment { get; set; } = string.Empty;
    }

    class LipidDefinition {
        public string Name { get; set; } = string.Empty;
        public int NumOfChains { get; set; }
    }
}
