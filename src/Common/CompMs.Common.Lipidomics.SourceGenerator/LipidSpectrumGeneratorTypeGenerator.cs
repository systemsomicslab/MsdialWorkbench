using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;
using System.Text;
using System.Xml.Linq;

namespace CompMs.Common.Lipidomics.SourceGenerator;

[Generator(LanguageNames.CSharp)]
public partial class LipidSpectrumGeneratorTypeGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context) {
#if DEBUG
        if (!System.Diagnostics.Debugger.IsAttached) {
            // System.Diagnostics.Debugger.Launch();
        }
#endif

        var additionalFiles = context.AdditionalTextsProvider
            .Where(f => f.Path.EndsWith(".xml"));
        var metadataProvider = context.AnalyzerConfigOptionsProvider
            .Select((provider, _) => provider);
        var targetFiles = additionalFiles.Combine(metadataProvider)
            .SelectMany((pair, cancellationToken) => {
                var (file, provider) = pair;
                var metadata = provider.GetOptions(file);
                //metadata.TryGetValue("build_metadata.Category", out var xxx);
                //metadata.TryGetValue("build_metadata.AdditionalFiles.Category", out var yyy);

                return metadata.TryGetValue("build_metadata.Category", out var category)
                    ? new[] { new { Path = file.Path, Category = category, File = file, } }
                    : new[] { new { Path = file.Path, Category = string.Empty, File = file, } };
            }).Collect();

        context.RegisterSourceOutput(targetFiles, (spc, files) => {
            var defs = CollectDefinitions(files.Select(f => f.File).ToList(), spc.CancellationToken);
            foreach (var group in files.GroupBy(f => f.Category)) {
                Emit(spc, group.Select(o => o.File), group.Key, defs);
            }
        });

        context.RegisterPostInitializationOutput(EmitStandardFormulas);
    }

    private List<LipidDefinition> CollectDefinitions(IEnumerable<AdditionalText> files, CancellationToken token) {
        var results = new List<LipidDefinition>();
        foreach (var file in files) {
            var content = file.GetText(token)?.ToString();
            if (content is null) {
                continue;
            }

            var doc = XDocument.Parse(content);
            foreach (var def in doc.Descendants("LipidDefinition")) {
                results.Add(new LipidDefinition
                {
                    Name = def.Element("Name")?.Value ?? string.Empty,
                    NumOfChains = int.TryParse(def.Element("Chain")?.Value, out var n) ? n : 0,
                });
            }
        }
        return results;
    }

    private static void EmitStandardFormulas(IncrementalGeneratorPostInitializationContext context) {
        context.AddSource("StandardFormulas.cs", """
// <auto-generated/>
#nullable enable
#pragma warning disable CS8600
#pragma warning disable CS8601
#pragma warning disable CS8602
#pragma warning disable CS8603
#pragma warning disable CS8604

using CompMs.Common.FormulaGenerator.DataObj;
using System;

namespace CompMs.Common.Lipidomics {

    internal static class StandardFormulas {
        public static readonly double H2O = MassDiffDictionary.HydrogenMass * 2 + MassDiffDictionary.OxygenMass;
        public static readonly double C = MassDiffDictionary.CarbonMass;
        public static readonly double Carbon = MassDiffDictionary.CarbonMass;
        public static readonly double H = MassDiffDictionary.HydrogenMass;
        public static readonly double Hydrogen = MassDiffDictionary.HydrogenMass;
        public static readonly double N = MassDiffDictionary.NitrogenMass;
        public static readonly double Nitrogen = MassDiffDictionary.NitrogenMass;
        public static readonly double O = MassDiffDictionary.OxygenMass;
        public static readonly double Oxygen = MassDiffDictionary.OxygenMass;
        public static readonly double S = MassDiffDictionary.SulfurMass;
        public static readonly double Sulfur = MassDiffDictionary.SulfurMass;
        public static readonly double P = MassDiffDictionary.PhosphorusMass;
        public static readonly double Phosphorus = MassDiffDictionary.PhosphorusMass;
        public static readonly double Proton = MassDiffDictionary.ProtonMass;
        public static readonly double Electron = MassDiffDictionary.HydrogenMass - MassDiffDictionary.ProtonMass;
        public static readonly double HCOO = H * 2.0 + C * 1 + O * 2.0 - Proton;
        public static readonly double CH3COO = H * 4.0 + C * 2 + O * 2.0 - Proton;
        public static readonly double Sodium = 22.98976928;
        public static readonly double Na = Sodium - Electron;
    }
}
""");
    }

    private static void Emit(SourceProductionContext spc, IEnumerable<AdditionalText> files, string? category, List<LipidDefinition> defs) {
        var result = new StringBuilder();
        result.Append("""
// <auto-generated/>
#nullable enable
#pragma warning disable CS8600
#pragma warning disable CS8601
#pragma warning disable CS8602
#pragma warning disable CS8603
#pragma warning disable CS8604

using CompMs.Common.Components;
using CompMs.Common.DataObj.Property;
using CompMs.Common.FormulaGenerator.DataObj;
using static CompMs.Common.Lipidomics.StandardFormulas;
using System;
using System.ComponentModel;

namespace CompMs.Common.Lipidomics {

""");

        IEnumerable<XElement> lipidMSElements = [];
        foreach (var file in files) {
            var content = file.GetText(spc.CancellationToken)?.ToString();
            if (content is null) {
                continue;
            }

            var doc = XDocument.Parse(content);
            lipidMSElements = lipidMSElements.Concat(doc.Descendants("LipidMS").Where(e => e.Elements("LipidClass").Any()));
        }

        foreach (var group in lipidMSElements.GroupBy(e => e.Element("LipidClass").Value)) {
            var lipidClass = group.Key;

            var lipidMSs = group.Select(ToLipidMS).ToList();

            result.AppendLine();
            result.AppendLine($"    public sealed class {lipidClass}{category ?? string.Empty}LipidSpectrumGenerator  {{");

            result.AppendLine("""
        public List<SpectrumPeak>? Generate(Lipid lipid, AdductIon adduct) {
            double M;
            var chains = lipid.Chains.GetDeterminedChains();
""");

            var def = defs.FirstOrDefault(d => d.Name == lipidClass);
            if (def is not null) {
                result.AppendLine($"""
            double {string.Join(", ", Enumerable.Range(1, def.NumOfChains).Select(i => "SN" + i))};
""");
            }

            result.AppendLine("""
            var peaks = new List<SpectrumPeak>();
            switch (adduct.AdductIonName) {
""");

            foreach (var lipidMS in lipidMSs) {
                result.AppendLine($"""
                case "{lipidMS.Adduct}":
                    M = lipid.Mass;
""");

                if (def is not null && lipidMS.Ions.SelectMany(ions => ions.Value).Any(ion => ion.Mz.Contains("SN"))) {
                    result.AppendLine(ForEachLine("                    ", Enumerable.Range(0, def.NumOfChains).Select(i => $"SN{i + 1} = chains[{i}].Mass;")));
                }

                foreach (var ions in lipidMS.Ions) {
                    if (!ions.Value.Any()) {
                        continue;
                    }

                    result.AppendLine($"""

                    // {ions.Key}
                    peaks.AddRange([
{ForEachLine("                        ", ions.Value.Select(ion => $"new SpectrumPeak({ion.Mz}, {ion.Intensity}, \"{ion.Comment}\"),"))}
                    ]);
""");
                }

                result.AppendLine("""
                    return peaks;

""");
            }

            result.AppendLine("""
                default: return null;
            }
        }
""");


            result.AppendLine("    }");
        }

        result.AppendLine("}");
        spc.AddSource($"{category}LipidSpectrumGenerator.g.cs", SourceText.From(result.ToString(), Encoding.UTF8));
    }

    private static string ForEachLine(string indent, IEnumerable<string> contents) {
        return indent + string.Join(Environment.NewLine + indent, contents);
    }

    readonly static List<string> _specialElements = ["LipidClass", "LSILevel", "Adduct"];

    private static LipidMS ToLipidMS(XElement element) {
        var adduct = element.Element("Adduct")?.Value ?? string.Empty;
        var lsiLevel = Enum.TryParse<LSILevel>(element.Element("LSILevel")?.Value, out var lsi) ? lsi : LSILevel.None;
        var ions = new Dictionary<string, List<Ion>>();


        var ionElements = element.Elements().Where(e => !_specialElements.Contains(e.Name.LocalName));

        foreach (var ionGroup in ionElements) {
            var key = ionGroup.Name.LocalName;
            if (!ions.TryGetValue(key, out var list)) {
                ions[key] = ionGroup.Elements().Select(ToIon).ToList();
                continue;
            }
            list.AddRange(ionGroup.Elements().Select(ToIon).ToList());
        }

        return new(adduct, lsiLevel, ions);
    }

    readonly static List<string> _peakElements = ["MZ", "Intensity", "Comment", "Charge", "Formula"];

    private static Ion ToIon(XElement element) {
        var mz = element.Element("MZ")?.Value ?? "0";
        var intensity = element.Element("Intensity")?.Value ?? "0";
        var comment = element.Element("Comment")?.Value ?? string.Empty;
        var charge = element.Element("Charge")?.Value ?? "0";
        var formula = element.Element("Formula")?.Value ?? string.Empty;

        if (mz != "0") {
            foreach (var (name, pairs) in ParseElements(element)) {
                var f = string.Join(" + ", pairs.Select(e => $"{e.LocalName} * {e.Value}"));
                mz = mz.Replace(name, $"({f})");
            }
        }
        else if (formula != string.Empty && charge != "0" && int.TryParse(charge, out var c)) {
            foreach (var (name, pairs) in ParseElements(element)) {
                var f = string.Join(" + ", pairs.Select(e => $"{e.LocalName} * {e.Value}"));
                formula = formula.Replace(name, $"({f})");
            }
            mz = $"(({formula}) - ({c} * Electron)) / {Math.Abs(c)}";
        }

        return new() { Mz = mz, Intensity = intensity, Comment = comment };
    }

    private static IEnumerable<(string LocalName, (string LocalName, string Value)[])> ParseElements(XElement element) {
        foreach (var variable in element.Elements().Where(e => !_peakElements.Contains(e.Name.LocalName))) {
            if (FormulaStringParser.CanConvertToFormulaDictionary(variable.Value)) {
                var dict = FormulaStringParser.ConvertToFormulaDictionary(variable.Value);
                yield return (variable.Name.LocalName, dict.Select(kvp => (kvp.Key, kvp.Value.ToString())).ToArray());
                continue;
            }

            yield return (variable.Name.LocalName, variable.Elements().Select(e => (e.Name.LocalName, e.Value)).ToArray());
        }
    }

    enum LSILevel {
        None,
        SpeciesLevel,
        MolecularSpeciesLevel,
    }

    class LipidMS(string adduct, LSILevel lsiLevel, Dictionary<string, List<Ion>> ions) {
        public string Adduct { get; } = adduct;
        public LSILevel LSILevel { get; } = lsiLevel;
        public Dictionary<string, List<Ion>> Ions { get; } = ions;
    }

    class Ion
    {
        public string Mz { get; set; } = "0";
        public string Intensity { get; set; } = "0";
        public string Comment { get; set; } = string.Empty;
    }

    class LipidDefinition {
        public string Name { get; set; } = string.Empty;
        public int NumOfChains { get; set; }
    }
}
