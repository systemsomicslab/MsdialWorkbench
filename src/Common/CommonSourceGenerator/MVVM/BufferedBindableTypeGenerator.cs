using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using System.Diagnostics;
using System.Text;

namespace CompMs.CommonSourceGenerator.MVVM
{
    [Generator(LanguageNames.CSharp)]
    public partial class BufferedBindableTypeGenerator : IIncrementalGenerator
    {
        public void Initialize(IncrementalGeneratorInitializationContext context) {
#if DEBUG
            if (!Debugger.IsAttached) {
                // Debugger.Launch();
            }
#endif
            context.RegisterPostInitializationOutput(static context => {
                context.AddSource("BufferedBindableTypeAttribute.cs", """
// <auto-generated/>
#nullable enable
#pragma warning disable CS8600
#pragma warning disable CS8601
#pragma warning disable CS8602
#pragma warning disable CS8603
#pragma warning disable CS8604

using System;

namespace CompMs.CommonSourceGenerator.MVVM {
    [AttributeUsage(AttributeTargets.Class, AllowMultiple = false, Inherited = false)]
    internal sealed class BufferedBindableTypeAttribute : Attribute {
        public Type? type;

        public BufferedBindableTypeAttribute(Type type) {
            this.type = type;
        }
    }
}
""");
            });

            var source = context.SyntaxProvider.ForAttributeWithMetadataName(
                "CompMs.CommonSourceGenerator.MVVM.BufferedBindableTypeAttribute",
                static (node, token) => true,
                static (context, token) => context);

            context.RegisterSourceOutput(source, Emit);
        }


        private static void Emit(SourceProductionContext context, GeneratorAttributeSyntaxContext source) {
            var typeSymbol = (INamedTypeSymbol)source.TargetSymbol;
            var typeNode = (TypeDeclarationSyntax)source.TargetNode;

            var attr = source.Attributes.First(a => a.AttributeClass!.Name == "BufferedBindableTypeAttribute");
            TypedConstant argument = attr.ConstructorArguments[0];
            var namedTypeSymbol = (INamedTypeSymbol)argument.Value!;
            var valueType = namedTypeSymbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);

            StringBuilder sb = new();

            var properties = namedTypeSymbol.GetMembers()
                        .Where(x => x is IPropertySymbol and { IsStatic: false, DeclaredAccessibility: Accessibility.Public, IsImplicitlyDeclared: false, CanBeReferencedByName: true, IsReadOnly: false })
                        .Cast<IPropertySymbol>();
            ToGetterOnlyProperty(sb, namedTypeSymbol, out var cares);
            ToBindableProperty(sb, cares, properties);

            var ns = typeSymbol.ContainingNamespace.IsGlobalNamespace
                ? ""
                : $"namespace {typeSymbol.ContainingNamespace}";
            var fullType = typeSymbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)
                .Replace("global::", "")
                .Replace("<", "_")
                .Replace(">", "_");

            var code = $$"""
// <auto-generated/>
#nullable enable
#pragma warning disable CS8600
#pragma warning disable CS8601
#pragma warning disable CS8602
#pragma warning disable CS8603
#pragma warning disable CS8604

using System;
using System.ComponentModel;

{{ns}} {

    partial class {{typeSymbol.Name}} : INotifyPropertyChanged
    {
        private readonly {{valueType}} _innerModel;

        public event PropertyChangedEventHandler? PropertyChanged;

        public {{typeSymbol.Name}}({{valueType}} innerModel) {
            _innerModel = innerModel ?? throw new ArgumentNullException("innerModel");
{{string.Join("\r\n", properties.Select(p => $$"""
            {{p.Name}} = innerModel.{{p.Name}};
"""))}}

            Initialized();
        }

{{sb}}

        public void Commit() {
{{string.Join("\r\n", properties.Select(p => $$"""
            _innerModel.{{p.Name}} = {{p.Name}};
"""))}}
            Committed();
        }

        protected virtual void RaisePropertyChanged(PropertyChangedEventArgs args) => PropertyChanged?.Invoke(this, args);
        protected void RaisePropertyChanged(string propertyname) => RaisePropertyChanged(new PropertyChangedEventArgs(propertyname));

        partial void Initialized();
        partial void Committed();
    }
}
""";
            context.AddSource($"{fullType}.BufferedBindableTypeGenerator.g.cs", code);
        }

        private static void ToBindableProperty(StringBuilder sb, Dictionary<string, HashSet<string>> cares, IEnumerable<IPropertySymbol> properties) {
            foreach (var property in properties) {
                IEnumerable<string> additionals = Enumerable.Empty<string>();
                if (cares.TryGetValue(property.Name, out var care)) {
                    additionals = care;
                }
                var field = "_" + char.ToLower(property.Name[0]) + property.Name.Substring(1);
                var additional = string.Join("\r\n", additionals.Prepend($"{property.Name}").Select(c => $$"""
                    RaisePropertyChanged("{{c}}");
"""));
                sb.AppendLine($$"""
        public {{property.Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)}} {{property.Name}} {
            get {
                return {{field}};
            }
            set {
                if (!Equals({{field}}, value)) {
                    {{field}} = value;
{{additional}}
                }
            }
        }
        private {{property.Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)}} {{field}};

""");
            }
        }

        private static void ToGetterOnlyProperty(StringBuilder sb, INamedTypeSymbol typeSymbol, out Dictionary<string, HashSet<string>> cares) {
            var properties = typeSymbol.GetMembers()
                        .Where(x => x is IPropertySymbol and { IsStatic: false, DeclaredAccessibility: Accessibility.Public, IsImplicitlyDeclared: false, CanBeReferencedByName: true, IsReadOnly: true })
                        .Cast<IPropertySymbol>()
                        .ToArray();
            cares = new Dictionary<string, HashSet<string>>();
            var getters = new HashSet<string>();
            foreach (var property in properties) {
                getters.Add(property.Name);
                var getterSyntax = property.GetMethod?.DeclaringSyntaxReferences[0].GetSyntax();// as MethodDeclarationSyntax;
                if (getterSyntax is not null) {
                    foreach (var node in getterSyntax.DescendantNodes().OfType<IdentifierNameSyntax>()) {
                        if (!cares.TryGetValue(node.Identifier.Text, out var props)) {
                            cares[node.Identifier.Text] = props = new HashSet<string>();
                            }
                            props.Add(property.Name);
                        }
                    }
                sb.AppendLine($$"""
        public {{property.Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)}} {{property.Name}} => _innerModel.{{property.Name}};

""");
            }

            foreach (var getter in getters) {
                if (!cares.ContainsKey(getter)) {
                    continue;
                }
                foreach (var care in cares.Values) {
                    if (care.Contains(getter)) {
                        care.UnionWith(cares[getter]);
                    }
                }
            }
        }
    }
}
