using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using System.Diagnostics;
using System.Text;

namespace CompMs.CommonSourceGenerator.MVVM
{
    [Generator(LanguageNames.CSharp)]
    public partial class WrapToBindableTypeGenerator : IIncrementalGenerator
    {
        public void Initialize(IncrementalGeneratorInitializationContext context) {
#if DEBUG
            if (!Debugger.IsAttached) {
                // Debugger.Launch();
            }
#endif
            context.RegisterPostInitializationOutput(static context => {
                context.AddSource("WrapToBindableTypeAttribute.cs", """
// <auto-generated/>
#nullable enable
#pragma warning disable CS8600
#pragma warning disable CS8601
#pragma warning disable CS8602
#pragma warning disable CS8603
#pragma warning disable CS8604

using System;

namespace CompMs.CommonSourceGenerator.MVVM {
    [AttributeUsage(AttributeTargets.Class, AllowMultiple = false, Inherited = false)]
    internal sealed class WrapToBindableTypeAttribute : Attribute {
        public Type? type;

        public WrapToBindableTypeAttribute(Type type) {
            this.type = type;
        }
    }
}
""");
            });

            var source = context.SyntaxProvider.ForAttributeWithMetadataName(
                "CompMs.CommonSourceGenerator.MVVM.WrapToBindableTypeAttribute",
                static (node, token) => true,
                static (context, token) => context);

            context.RegisterSourceOutput(source, Emit);
        }


        private static void Emit(SourceProductionContext context, GeneratorAttributeSyntaxContext source) {
            var typeSymbol = (INamedTypeSymbol)source.TargetSymbol;
            var typeNode = (TypeDeclarationSyntax)source.TargetNode;

            var attr = source.Attributes.First(a => a.AttributeClass!.Name == "WrapToBindableTypeAttribute");
            TypedConstant argument = attr.ConstructorArguments[0];
            var namedTypeSymbol = (INamedTypeSymbol)argument.Value!;
            var valueType = namedTypeSymbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);

            StringBuilder sb = new();

            ToGetterOnlyProperty(sb, namedTypeSymbol, out var cares);
            ToBindableProperty(sb, namedTypeSymbol, cares);

            var ns = typeSymbol.ContainingNamespace.IsGlobalNamespace
                ? ""
                : $"namespace {typeSymbol.ContainingNamespace}";
            var fullType = typeSymbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)
                .Replace("global::", "")
                .Replace("<", "_")
                .Replace(">", "_");

            var code = $$"""
// <auto-generated/>
#nullable enable
#pragma warning disable CS8600
#pragma warning disable CS8601
#pragma warning disable CS8602
#pragma warning disable CS8603
#pragma warning disable CS8604

using System;
using System.ComponentModel;

{{ns}} {

    partial class {{typeSymbol.Name}} : INotifyPropertyChanged
    {
        private readonly {{valueType}} _innerModel;

        public event PropertyChangedEventHandler? PropertyChanged;

        public {{typeSymbol.Name}}({{valueType}} innerModel) {
            _innerModel = innerModel ?? throw new ArgumentNullException("innerModel");
        }

{{sb}}
        protected virtual void RaisePropertyChanged(PropertyChangedEventArgs args) => PropertyChanged?.Invoke(this, args);
        protected void RaisePropertyChanged(string propertyname) => RaisePropertyChanged(new PropertyChangedEventArgs(propertyname));
    }
}
""";
            context.AddSource($"{fullType}.WrapToBindableTypeGenerator.g.cs", code);
        }

        private static void ToBindableProperty(StringBuilder sb, INamedTypeSymbol typeSymbol, Dictionary<string, HashSet<string>> cares) {
            IEnumerable<IPropertySymbol> properties = typeSymbol.GetMembers()
                .Where(x => x is IPropertySymbol and { IsStatic: false, DeclaredAccessibility: Accessibility.Public, IsImplicitlyDeclared: false, CanBeReferencedByName: true, IsReadOnly: false })
                .Cast<IPropertySymbol>();
            foreach (var property in properties) {
                IEnumerable<string> additionals = Enumerable.Empty<string>();
                if (cares.TryGetValue(property.Name, out var care)) {
                    additionals = care;
                }
                var additional = string.Join("\r\n", additionals.Prepend($"{property.Name}").Select(c => $$"""
                    RaisePropertyChanged("{{c}}");
"""));
                sb.AppendLine($$"""
        public {{property.Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)}} {{property.Name}} {
            get {
                return _innerModel.{{property.Name}};
            }
            set {
                if (!Equals(_innerModel.{{property.Name}}, value)) {
                    _innerModel.{{property.Name}} = value;
{{additional}}
                }
            }
        }

""");
            }
        }

        private static void ToGetterOnlyProperty(StringBuilder sb, INamedTypeSymbol typeSymbol, out Dictionary<string, HashSet<string>> cares) {
            var properties = typeSymbol.GetMembers()
                .Where(x => x is IPropertySymbol and { IsStatic: false, DeclaredAccessibility: Accessibility.Public, IsImplicitlyDeclared: false, CanBeReferencedByName: true, IsReadOnly: true })
                .Cast<IPropertySymbol>();
            cares = new Dictionary<string, HashSet<string>>();
            var getters = new HashSet<string>();
            foreach (var property in properties) {
                getters.Add(property.Name);
                var getterSyntax = property.GetMethod?.DeclaringSyntaxReferences[0].GetSyntax();// as MethodDeclarationSyntax;
                if (getterSyntax is not null) {
                    foreach (var node in getterSyntax.DescendantNodes().OfType<IdentifierNameSyntax>()) {
                        if (!cares.TryGetValue(node.Identifier.Text, out var props)) {
                            cares[node.Identifier.Text] = props = new HashSet<string>();
                            }
                            props.Add(property.Name);
                        }
                    }
                sb.AppendLine($$"""
        public {{property.Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)}} {{property.Name}} => _innerModel.{{property.Name}};

""");
            }

            foreach (var getter in getters) {
                if (!cares.ContainsKey(getter)) {
                    continue;
                }
                foreach (var care in cares.Values) {
                    if (care.Contains(getter)) {
                        care.UnionWith(cares[getter]);
                    }
                }
            }
        }
    }

    public static class DiagnosticDescriptors
    {
        const string Category = "WrapToBindableTypeGenerator";
    }
}
